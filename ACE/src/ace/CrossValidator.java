/*
 * CrossValidator.java
 * Version 2.2
 *
 * Last modified on April 11, 2010.
 * McGill University
 */

package ace;

import java.io.*;
import java.text.*;
import ace.datatypes.*;
import weka.core.*;
import java.util.LinkedList;


/**
 * Cross validates a set of Weka Instances.
 *
 * <p> Instances are partitioned into folds. Different instances are used for training
 * and testing in each fold. A Weka Classifier is trained and tested for each fold.
 * Results are used to evaluate the performance of various classification techniques,
 * including feature selection and classifier ensembles. Methods of this class are
 * used both in the context of a single cross validation and in the context of experimentation
 * where multiple cross validations are performed.
 *
 * <p> Instances are partitioned in the constructor of this class. An array of integers
 * generated by a call to <i>generatePartitionAray</i> stores the directions for
 * the partitioning. This array is either generated in the constructor (in the context
 * of a single cross validation) or in the <i>Experimenter</i> class (in the context
 * of experimentation).
 *
 * @author Cory McKay (ACE 1.x) and Jessica Thompson (ACE 2.x)
 */
public class CrossValidator
{
    /* FIELDS ****************************************************************/

    /**
     * 3D array to store partitioned instances. Stores a training set and a testing
     * set for each fold of the cross validation. First index indicates the fold.
     * Second index indicated whether the Instance will be part of the training
     * set or the testing set for that fold; the Instance objects with a second
     * index of 1 will be used for testing, and those with a second index of zero
     * will be used for training. One instance can only be either used for training
     * or testing for any one fold, not both. Note that this only accounts for half
     * of the entries in this array; the other half of the entries will be set to null;
     */
    Instance [][][] folds;

    String[][][] names;

    /* CONSTRUCTORS **********************************************************/

    /**
     * This constructor will be called when a single cross validation is being
     * performed with only one type of Classifier and one type of dimensionality reduction.
     * The partition array is created.
     *
     * @param instances     The Weka Instances to be used for cross validation.
     * @param num_folds     The number of folds into which the Instances should
     *                      be partitioned.
     * @param identifiers   String of unique identifiers for the given Instances.
     *                      These identifiers will be partitioned alongside the Instances.
     * @param num_overall   The number of overall instances (non subsections) in
     *                      this data set.
     * @param hierarchy     Contains information about how the given Instances might
     *                      have been modified or rearranged. Maps current Instances
     *                      to original set (pre randomization/deletion).
     */
        public CrossValidator(Instances instances, int num_folds, String[] identifiers, int num_overall, String[] hierarchy)
    {
        // Generate array of evenly distributed random numbers
        int[] partition = generatePartitionArray(num_folds, num_overall);

        // Partition instances based on array
        folds = partitionInstances(instances, partition, num_folds, identifiers, hierarchy);

    }

    /**
     * This constructor will be called in the context of Experimentation when multiple
     * Classifiers and types of dimensionality reduction are being used. The partition
     * array is passed as a parameter in this case because the partitioning of the
     * Instances must be identical for each cross validation.
     *
     * @param instances     The instances to be used for cross validation.
     * @param partition     An array of numbers that specify the way in which the
     *                      given Instances should be partitioned. This parameter
     *                      is necessary in the context of
     * @param num_folds     The number of folds into which the Instances should
     *                      be partitioned.
     * @param hierarchy     Contains information about how the given Instances might
     *                      have been modified or rearranged. Maps current Instances
     *                      to original set (pre randomization/deletion).
     * @param identifiers   Contains one name or 'identifier' for each instance (even subsections).
     */
    public CrossValidator(Instances instances, int[] partition, int num_folds,
            String[] hierarchy, String[] identifiers)
    {
        // Partition instances based on given array, store in field
        folds = partitionInstances(instances, partition, num_folds, identifiers, hierarchy);
    }

    /* PUBLIC METHODS ********************************************************/

    /**
     * Cross validates a set of Weka Instances.
     *
     * @param trained                   The Serializable object that stores the Weka Classifier
     *                                  and dimensionality reduction objects.
     * @param cvres                     Holds the results of the cross validation. In the
     *                                  context of a single cross validation, an array of
     *                                  size one is passed. In the context of experimentation,
     *                                  the array will have a cell for each Classifier that
     *                                  is being tested.
     * @param instances                 The Weka Instances to use in cross validation.
     * @param out                       A progess report is printed to this OutputStream.
     * @param cv_results                Results of the cross validation are appended to
     *                                  this StringBuffer. In the context of a single
     *                                  cross validation, this will be instantiated in
     *                                  <i>Coordinator</i> and will only be accessed by
     *                                  this method. In the context of experimentation,
     *                                  <i>Experimenter</i> will instantiate and also write
     *                                  to this StringBuffer.
     * @param file_name                 The file to save the results to. The content
     *                                  of this file will be the same that is returned.
     *                                  This string will always be null in the context
     *                                  of experimentation because <i>Experimenter</i>
     *                                  writes the results to a file itself.
     * @param feature_selector          The name of the feature selector being used
     *                                  for this cross validation. If null, "None"
     *                                  will be printed in the results sting as
     *                                  the type of dimensionality reduction performed.
     * @param save_intermediate_arffs   Whether or not to save training data to an
     *					arff file after parsing, after thinning and,
     *					and again after feature	selection, if any.
     * @param verbose                   Whether or not to print and save a detailed report
     *                                  of the cross validation, including the partitioning
     *                                  and classification of individual instances
     *                                  and detailed report of dimensionality reduction
     *                                  that was performed. Incorrect classifications
     *                                  are marked with an asterix.
     * @param i                         The index of the array of <i>CrossValidationResults</i>
     *                                  objects to access. This will always be 0 in the
     *                                  context of a single cross validation.
     * @return                          A string containing a summary of the results
     *                                  of this cross validation.
     * @throws Exception                If a problem occurs.
     *
     */
    public String crossValidate(TrainedModel trained,
            CrossValidationResults[] cvres,
            Instances instances,
            OutputStream out,
            StringBuffer cv_results,
            String file_name,
            String feature_selector,
            boolean save_intermediate_arffs,
            boolean verbose,
            int i)
            throws Exception
    {
        // Give progress report to the user
        out.write(("\tCross Validating....\n").getBytes());

        // Get measurments and objects needed for the calculation of cross validation statistics
        // Limit measurments to 2 decimal places
        DecimalFormat df = new DecimalFormat("####0.0#");
        long cross_val_start_time = System.currentTimeMillis();
        int num_folds = folds.length;
        // Array to store error rates of each fold
        double[] error_rates = new double[num_folds];
        // Array to store confusion matricies for each fold
        // First index is actual classification, second index is predicted classification
        double[][][] confusion_matrices = new double[num_folds][][];
        // Get class names from instances for use in confusion matrix
        String[] classes = getClassNames(instances);

        // Initialize StringBuffer object to store a summary of the results of this
        // cross validation
        StringBuffer to_return = new StringBuffer();
        StringBuffer per_fold = new StringBuffer();
        per_fold.append("\n==================================================\n");
        per_fold.append("\n----------RESULTS PER FOLD----------\n");

        // Perform and time the cross-validation
        // For each fold, train, test, and store.
        for (int fold = 0; fold < num_folds; fold++)
        {
            // Initialize empty Instances objects to store training and testing data
            Instances training = new Instances(instances, 100);
            Instances testing = new Instances(instances, 100);

            // Get training and testing instances
            // Appropriate instances are added to Instances objects training and testing
            String[][] identifiers = getPartitionedInstances(training, testing, fold);
            // Train the Classifier
            Trainer.train(training, trained);

            // Test the Classifier, store results
            Instances classified = InstanceClassifier.classifyInstances(trained, testing,
                    save_intermediate_arffs);

            // Calculate statistics per fold
            // Get error rate and confusion matrix for this classification
            double correct_count = InstanceClassifier.getCorrectCount(testing, classified);
            double total_count = (double) testing.numInstances();
            double success_rate = 100.0 * correct_count / total_count;
            error_rates[fold] = 100 - success_rate;
            confusion_matrices[fold] = InstanceClassifier.getConfusionMatrix(testing, classified, classes);

            // Only collect summary of statistics per fold when performing a single cross validation
            if(cvres.length == 1)
            {
                per_fold.append("\n*************** FOLD: " + fold + " ***************");
                per_fold.append("\nSuccess rate: " + df.format(success_rate));
                per_fold.append("\nConfusion matrix: \n" + InstanceClassifier.formatConfusionMatrix(confusion_matrices[fold], classes));
                // Give report of individual classifications if verbose option was specified
                if(verbose)
                    per_fold.append(getClassifications(testing, classified, training, identifiers) + "\n");
            }
        }
        // Keep track of how long the cross validation took to finish.
        long cross_val_end_time = System.currentTimeMillis();

        // Calculate and store statistics overall
        //cvres[i].classifier_descriptions = (trained.classifier.getClass().toString().substring(trained.classifier.getClass().toString().lastIndexOf(".")+1));
        cvres[i].error_rates = mckay.utilities.staticlibraries.MathAndStatsMethods.getAverage(error_rates);
        cvres[i].cross_val_times = ((double) (cross_val_end_time - cross_val_start_time)) / 60000.0;
        cvres[i].standard_deviation = mckay.utilities.staticlibraries.MathAndStatsMethods.getStandardDeviation(error_rates);
        double[][] average_confusion_matrix = getOverallConfusionMatrix(confusion_matrices);
        cvres[i].cross_validation_confusion_matrices = InstanceClassifier.formatConfusionMatrix(average_confusion_matrix, classes);
        cvres[i].trained = trained;

        // Prepare summary of cross validation results
        // This StringBuffer is used to temporarily store the main statistics that
        // need to be accessed by both cross validation and experimentation
        StringBuffer both = new StringBuffer();
        to_return.append("\n==================================================\n");
        cv_results.append("\n==================================================\n");
        to_return.append("\n----------AVERAGE RESULTS----------\n");
        both.append("\nAVERAGE SUCCESS RATE: " + df.format(100.0 - cvres[i].error_rates) + "%");
        both.append("\nAVERAGE ERROR RATE: " + df.format(cvres[i].error_rates) + "%\n");
        both.append("STANDARD DEVIATION: " + df.format(cvres[i].standard_deviation) + "\n");
        both.append("TOTAL CROSS-VALIDATION TIME: " + cvres[i].cross_val_times + " minutes\n");
        cv_results.append(both);
        to_return.append(both);
        // Only include these statistics when performing a single cross validation (not experimenting)
        if (cvres.length == 1)
        {
            // Store a short description of the dimensionality reduction that was performed
            String dr;
            if (trained.attribute_selector != null)
                dr = feature_selector;
            else
                dr = "None";

            to_return.append("\nNUMBER OF FOLDS: " + num_folds + "\n");
            //cv_results.append("CROSS-VALIDATION STATISTICS:\n" + cvres.cross_validation_statistics + "\n");
            to_return.append("CONFUSION MATRIX:\n" + cvres[i].cross_validation_confusion_matrices + "\n");
            to_return.append("DIMENSIONALITY REDUCTION: " + dr + "\n");
        }
        cv_results.append("CLASSIFIER TYPE: " + cvres[i].classifier_descriptions + "\n");
        to_return.append("CLASSIFIER TYPE: " + cvres[i].classifier_descriptions + "\n");

        // Create copy off per fold results for formatting output
        StringBuffer intermediate = new StringBuffer();
        intermediate.append(per_fold);
        intermediate.append(to_return);

        // Save to file if specified
        if(file_name != null)
        {
            File save_file = new File(file_name);
            FileOutputStream to = new FileOutputStream(save_file);
            DataOutputStream writer = new DataOutputStream(to);
            writer.writeBytes(to_return.append(per_fold).toString());
        }
        return intermediate.toString();
    }

    /**
     * Generates an array of evenly distributed random numbers between 0 and num_folds -1
     * to be used during the partitioning of Instances into cross validation folds.
     * An instance may only be a testing instance for one fold, and will be a training
     * instance for every other fold. By keeping track of for which fold each instance
     * is a testing instance, we can store the instructions for the partitioning
     * of a set of instances with a single array of integers. Each index of the
     * returned array corresponds to an instance and the value of of each index
     * of the array indicates for which fold that instance will be a testing instance.
     *
     *
     * @param num_folds         The number of folds into which the instances should
     *                          be divided.
     * @param num_instances     The number of instances to be partitioned.
     * @return                  Array of integers indicating which folds should
     *                          contain which instances as testing instances.
     */
    public static int[] generatePartitionArray(int num_folds, int num_instances)
    {
        // The array to fill and return
        int[] partition_array = new int[num_instances];

        // Keep track of how many testing instances we have assigned to each fold
        int[] count = new int[num_folds];

        // The random number
        int selected;

        // There may be no more than this many testing instances belonging to any one fold
        double max = Math.ceil((double)num_instances/num_folds);

        // If we already selected the random number at least max times.
        boolean over_max = false;

        // For each instance, assign which fold will contain the instance as a testing instance
        for(int i = 0; i < num_instances; i++)
        {
            do
            {
                // Generate a random number between 0 and num_folds -1
                selected = mckay.utilities.staticlibraries.MathAndStatsMethods.generateRandomNumber(num_folds);

                // If we have already generated this number max or more times, try again
                if(count[selected] >= max)
                {
                    over_max = true;
                    if (i >= num_instances -1)
                        over_max = false;
                }
                else
                {
                    over_max = false;

                }
                count[selected]++;
            }while(over_max);// Until an appropriate number has been selected

            // Store the randomly assigned partitioning instructions in array to return
            partition_array[i] = selected;
        }
        return partition_array;
    }

    /**
     * Gets the confusion matrix for the cross validation as a whole from the confusion
     * matrices of each fold. Corresponding values are simply summed. Total number
     * of instances represented in the matrix should be equal to the total number
     * of instances.
     *
     * @param confusion_matrices    3D array containing the confusion matrices for
     *                              each fold. First index will be the fold.
     * @return                      2D array containing the confusion matrix for
     *                              the cross validation over all.
     */
    public double[][] getOverallConfusionMatrix(double[][][] confusion_matrices)
    {
        // Size of second dimension (as well as third dimension) should be equal
        // number of classes
        int num_classes = confusion_matrices[1][1].length;
        int num_folds = confusion_matrices.length;
        int sum;
        double[][] average_matrix = new double[num_classes][num_classes];

        // For each predicted
        for(int a = 0; a < num_classes; a++)
        {
            // For each actual
            for (int p = 0; p < num_classes; p++)
            {
                // Calculate sum of each cell across folds
                sum = 0;
                for (int f = 0; f < num_folds; f++)
                {
                    sum += confusion_matrices[f][a][p];
                }
                average_matrix[a][p] = sum;
            }
        }
        return average_matrix;
    }


    /**
     * Gets the names of the possible classes into which an instance of the given
     * data set could be classified.
     *
     * @param instances     The Weka Instances in question.
     * @return              An array of class names for this set of Instances.
     */
    public static String[] getClassNames(Instances instances)
    {
        // Get possible classes into which instances could be classified.
        // Get at top level, classes could be different after
        String [] classes = new String[instances.numClasses()];
        for (int c = 0; c < instances.numClasses(); c++)
        {
            classes[c] = instances.classAttribute().value(c);
        }
        return classes;
    }

    /**
     * Prints the training instances and testing instances with their corresponding
     * model and predicted classification. An asterisk(*) is printed before the
     * instance if it was incorrectly classified and a caret(^) precedes the instance
     * if it was partially misclassified.
     *
     * This method is called when the verbose option is specified at the command line.
     * Model classifications must be present (model classifications will always
     * be present because this method is only called in the context of a cross validation).
     *
     * @param actual        The testing set of Weka Instances.
     * @param predicted     The classified Weka Instances that were returned by classification.
     * @param training      The training set of Weka Instances.
     * @param identifiers   2D array containing the identifiers for the training
     *                      and testing data. First index contains identifiers for
     *                      training data. Second index contains identifiers for
     *                      testing data.
     * @return              A detailed summary of the classification results.
     */
    public static StringBuffer getClassifications(Instances actual, Instances predicted, Instances training, String[][] identifiers)
    {
        //testInstanceIdentification(identifiers[1], actual);
        StringBuffer classes = new StringBuffer();
        for(int train = 0; train < identifiers[0].length; train++)
        {
            if(identifiers[0][train] != null)
            {
                if(train==0)
                    classes.append("\n----------Training Instances----------\n");
                classes.append("\n\nTraining Instance " + train + ": " + identifiers[0][train]);
                classes.append("\n\tModel Class: " + training.instance(train).stringValue(training.classIndex()));
            }
        }

        String actual_class;
        String predicted_class;
        for(int inst = 0; inst < actual.numInstances(); inst++)
        {
            if(identifiers[1][inst] != null)
            {
                if(inst==0)
                    classes.append("\n\n----------Testing Instances----------\n");
                actual_class = actual.instance(inst).stringValue(actual.classIndex());
                predicted_class = predicted.instance(inst).stringValue(predicted.classIndex());
                // Prepare a description of the comparison of the actual class to the predicted class
                classes.append("\n");
                if(!actual_class.equals(predicted_class))
                    classes.append("*");

                classes.append("Testing Instance " + inst + ": " + identifiers[1][inst]);
                classes.append("\n\tActual Class: " + actual_class);

                classes.append("\tPredicted Class: " + predicted_class + "\n");
            }
        }
        return classes;
    }

    /**
     * Uses the hierarchy String array to find the indeces of all top-level instances.
     *
     * @param hierarchy     A String array that distinguishes top-level instances from
     *                      subsections and links subsections to their corresponding top-
     *                      level instance.
     * @param num_overall   The number of top-level instances (not subsections).
     * @return              The indeces of all top-level instances.
     */
    public static int[] getIndecesOfOverallInstances(String[] hierarchy, int num_overall)
    {
     /*Maybe this could be modified to avoid String comparisons. Maybe use 1, 1.1, 1.2, 1.3
     instead of 1, 1_1, 1_2, 1_3.*/

        int[] indeces = new int[num_overall];
        int j = 0;
        for (int i = 0; i < hierarchy.length; i++)
        {
            if(!hierarchy[i].contains("_"))
            {
                indeces[j] = i;
                j++;
            }
        }
        return indeces;
    }

    /**
     * Uses the hierarchy array to find the indeces of all subsections of the given top-
     * level instance.
     *
     * @param hierarchy     A String array that distinguishes top-level instances from
     *                      subsections and links subsections to their corresponding top-
     *                      level instance.
     * @param overall       Identifies the top-level instance for which this method finds
     *                      all corresponding subsections.
     * @return              Indeces of all subsections corresponding to the specified
     *                      top-level instance.
     */
    public static Integer[] getIndecesOfSubsections(String[] hierarchy, String overall)
    {
        LinkedList<Integer> index_list = new LinkedList<Integer>();
        for (int i = 0; i < hierarchy.length; i++)
        {
            if(hierarchy[i].startsWith(overall + "_"))
            {
                index_list.add(i);
            }
        }
        return index_list.toArray(new Integer[0]);
    }


    /* PRIVATE METHODS *******************************************************/

    /**
     * Divides the given set of Instances into the specified number of folds based
     * on the random numbers in <i>partition</i> generated by the method <i>generatePartitionArray</i>.
     *
     *
     * @param partition     Array of integers that describes the partitioning of
     *                      this data set.
     * @return              Three dimensional array of Instances. First index corresponds
     *                      to the folds of the cross validation. Second index indicates
     *                      whether an instance is being used for training or testing
     *                      (0 if training, 1 if testing). The third index corresponds
     *                      to the Instances.
     *
     */
    private Instance[][][] partitionInstances(Instances instances2, int[] partition,
            int num_folds, String[] identifiers, String[] hierarchy)
    {
        // Make copy of Instances to be partitioned
        Instances instances = new Instances(instances2);
        Instance [][][] partitioned = new Instance[num_folds][2][instances.numInstances()];
        names = new String[num_folds][2][instances.numInstances()];
        int[] overall = getIndecesOfOverallInstances(hierarchy, partition.length);

        // For each fold
        for(int fold = 0; fold < num_folds; fold++)
        {
            for(int inst = 0; inst < partition.length; inst++)
            {
                // If instance is found to belong to training set
                if (partition[inst] == fold)
                {
                    // Put the instance in the second cell of the second index
                    partitioned[fold][1][inst] = instances.instance(overall[inst]);
                    names[fold][1][inst] = identifiers[overall[inst]];
                    // Set the first cell to null
                    partitioned[fold][0][inst] = null;

                    // If this overall instances has subsections, add them to same fold
                    Integer[] subs = getIndecesOfSubsections(hierarchy, hierarchy[overall[inst]]);

                    if(subs != null && subs.length > 0)
                    {
                        for(int i = 0; i < subs.length; i++)
                        {
                            partitioned[fold][1][inst+i+1] = instances.instance(subs[i].intValue());
                            names[fold][1][inst+i+1] = identifiers[subs[i].intValue()];
                            partitioned[fold][0][inst+i+1] = null;
                        }
                    }

                }
                // If instance is not found to belong to training set
                // then it belongs to the testing set
                else
                {
                    // Put instance in first cell of second index
                    partitioned[fold][0][inst] = instances.instance(inst);
                    names[fold][0][inst] = identifiers[inst];

                    // Set sescond cell to null
                    partitioned[fold][1][inst] = null;
                }
            }
        }
        return partitioned;
    }

    /**
     * Training and testing sets of Weka Instances objects are extracted from the
     * partitioned 3D array of Weka Instance objects.
     *
     * <p>For each instance of each fold, if the instance has a second index of 1,
     * the instance is added to the set of testing Instances, and is added to the
     * training set if the Instance has a second index of 0.
     *
     * @param folds         A 3D array of partitioned Weka Instance objects.
     * @param training      Will contain the training instances for this fold of
     *                      the cros validation.
     * @param testing       Will contain the testing instances for this fold of
     *                      the cross validation.
     * @param fold          Specifies the first index of the 3D Instance array folds
     *                      from which to extract the instances.
     */
    private String[][] getPartitionedInstances(Instances training, Instances testing, int fold)
    {
        String[][] name_array = new String[2][folds[fold][0].length];
        // For each cell in folds, add Instance to appropriate array if cell is not null
        int i = 0;
        int k = 0;
        for (int j = 0; j < folds[fold][0].length; j++)
        {

          if(folds[fold][0][j] != null)
          {
            training.add(folds[fold][0][j]);
            name_array[0][i] = names[fold][0][j];
            i++;
          }
          else if(folds[fold][1][j] != null)
          {
            testing.add(folds[fold][1][j]);
            name_array[1][k] = names[fold][1][j];
            k++;

          }
        }

        return name_array;
    }

    /**
     * Prepares a string that compares the feature values of an instance to its
     * identifier.
     *
     * @param identifiers   Array of identifiers that should correspond to the given
     *                      instances.
     * @param instances     The Weka instances to which the given array of identifiers
     *                      should correspond.
     */
    private static String testInstanceIdentification(String[] identifiers, Instances instances)
    {
        String compare = "";
        //identifiers = (String[])mckay.utilities.staticlibraries.ArrayMethods.removeNullEntriesFromArray(identifiers);
        //if(identifiers.length!=instances.numInstances())
            //System.out.println("Sorry, there are not the same amount of identifiers as there are instances!");
        //else
            for (int i = 0; i<instances.numInstances(); i++)
                System.out.println("\nidentifier: " + identifiers[i] + "\tfeatures: " + instances.instance(i).toString());

        return compare;
    }
}